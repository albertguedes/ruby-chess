c
n
c
moving_piece
possible_moves
n
position
self.class
n
self.class
n
self.color
c
n
display position
position
n
self.color
possible_moves
n
kills?(position)
self.class
self
possible_moves
position
c
self.grid[2][6]
c
exit
self.grid
self.board.grid[2][6]
self.grid[2][6]
self
valid_move?(position)
c
exit
kills?(position)
kills(position)
position
@grid[2][6]
@grid[2, 6]
self.pos
self
c
cc
c
cc
c
cc
c
cc
c
self
c
s
self
s
opposing_pieces.each do |piece| puts ("#{piece.class}, #{piece.pos}") end
opposing_pieces.each do |piece| puts piece.class piece.pos end
opposing_pieces.each do |piece| puts piece.class puts piece.pos end
opposing_pieces.each do |piece| puts piece.class end
opposing_pieces.each do |piece| puts piece.color end
opposing_pieces.each do |piece| puts piece.color
opposing_pieces.length
opposing_pieces[3].color
opposing_pieces.second.color
opposing_pieces.first.color
opposing_pieces
n
s
dup_board.check?(:black)
dup_board.grid[end_pos[0]][end_pos[1]]
dup_board.grid[end_pos[0]][endpos[1]]
dup_board.grid[moving_piece.pos[0]][moving_piece.pos[1]]
n
s
c
s
@grid[xstart][ystart]
moved_piece.pos
s
@grid[xend][yend]
s
moved_piece.pos
end_pos
moved_piece.pos
moved_piece
s
self
end_pos
start_pos
s
n
s
c
n
s
c
exit
end_pos
moving_piece.pos
moving_piece
dup_board.check?(moving_piece.color)
s
d.render
d.build_grid
d = Display.new(dup_board)
dup_board
sup_board
n
s
moved_into_check?(moving_piece, end_pos)
moving_piece
c
moved_into_check?(moving_piece, end_pos)
c
exit
moving_piece.opposite_color
check?(:white)
check?(:black)
n
end_pos
end_os
moving_piece.pos
n
@grid[end_row][end_col]
n
moved_into_check?(moving_piece, end_pos)
n
possible_moves.include?(end_pos)
end_pos
possible_moves
moving_piece.pos
moving_piece
moving_piece.color
exit
moving_piece.color
c
moving_piece
n
exit
@grid[start_row][start_col]
start
moving_piece
c
opposite_color
@color
n
possible_moves
end_pos
n
s
move
s
@grid[x][y].color
@grid[x][y]
s
@color
s
moving_piece
possible_moves
s
moving_piece
s
color
s
c
s
@current_player
pos_2
pos_1
n
@board
